class GameEngine
types
-- TODO Define types here
values
	public static player1 : int = 1;
	public static player2 : int = 2;
instance variables
	public p1: Player;
	public p2: Player;
	public board: Board; -- acho que só será preciso 1...
	public playerPlaying: int := player1; 
	public gameOver: bool:= false;
	public piece : Piece;
	
	inv playerPlaying in set {player1, player2};
	
operations

	public GameEngine: VDMUtil`String * VDMUtil`String ==> GameEngine
				 GameEngine(p1Name, p2Name) ==
				 (
				 		board := new Board();
				 
				 		p1 := new Player(p1Name, 1, board);
				 		p2 := new Player(p2Name, 2, board);
				 		
				 		
				-- 		board := p1.board; -- não sei se é necessário, secalhar mais vale tirar o board do player e por aqui diretamente
				 			
				 );
	
	public round: (int) ==> int
				 round(i) == 
				 (
				 		if playerPlaying = player1 then (
				 				let coordsP1 = p1.play(i) in
				 				(
				 						if i = 1 then(
											piece := new Piece(p1.piecesCoords(i),p1.positions(i),0,board, player1); --o valor numérico aqui indica o tipo de peça
											p1.pieces := p1.pieces ^ [piece];
										)
										
										elseif i <> 1 then(
											piece := new Piece(p1.piecesCoords(i),p1.positions(i),i-1,board, player1); --o valor numérico aqui indica o tipo de peça
											p1.pieces := p1.pieces ^ [piece];
										);
				 				
				 				
				 						gameOver := checkVictory(p1.pieces);
				 						board.mark(coordsP1);
				 						
				 						
				 						if gameOver then return playerPlaying;
				 						playerPlaying := player2;
				 				)
				 		)
				 		
				 		elseif playerPlaying = player2 then (
				 				let coordsP2 = p2.play(i) in
				 				(
				 			--			piece := new Piece(p2.piecesCoords(i),p2.positions(i),i-1,board, player2); --o valor numérico aqui indica o tipo de peça
							--			p2.pieces := p2.pieces ^ [piece];
				 						
				 						board.mark(coordsP2);
				 						gameOver := checkVictory(p2.pieces);
				 						
				 						
				 						if gameOver then return playerPlaying;
				 						playerPlaying := player1;
				 				)
				 		);
				 		
				 	return 0;
				 	
				 );
				 
		public checkVictory: seq of Piece ==> bool
					 checkVictory (pieces) ==
					 ( -- nao sei se pode ser assim
					 		return forall p in set elems pieces & p.played;
				 );
	
		public getPlayer: int ==> Player
					 getPlayer(no) ==
					 		let player in set {p1, p2} be st player.playerNo = no in (return player;);
	
	
	  public startGame : bool ==> int
	  			 startGame(menu) ==
	  			 (
	  			 		dcl winner: int := 0, loser: int := 1, count: int := 1;
	  			 		
	  			 		if menu then Menu`print(p1, p2);
	  			 		
	  			 		while not gameOver do
	  			 		(
	  			 				winner := round(count);
	  			 				if playerPlaying = player1 then (
	  			 					count:=count+1;
	  			 				);
	  			 				
	  			 		);
	  			 		
	  			 		if winner = player1 then loser := player2
	  			 		else loser := player1;
	  			 		
	  			 		if menu then (
	  			 			
	  			 			Menu`printBoard(board);
	  			 			
	  			-- 			Menu`printWinner(winner);
	  			 		
	  			 		);
	  			 		
	  			 		return winner;
	  			 
	  			 );
	  
	  
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end GameEngine